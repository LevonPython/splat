#ifndef SPLAT_PROCESSOR_H
#define SPLAT_PROCESSOR_H

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <bzlib.h>
#include <unistd.h>
#include "fontdata.h"
#include <iostream>
#include <sstream>
#include <fstream>
#include <iomanip>  // For formatting output
#include <memory>
#include <cstring>  // For strcmp
#include <vector>
#include "../include/splat_config.h"
#include <filesystem>
#include "sm_splat_info.h"
/*
  Parameters for 3 arc-second standard resolution mode of operation
  Generated by ./configure by levonyeghiazaryan on Mon Jan 20 01:02:33 PM +04 2025
*/
// #define HD_MODE 0
// #define MAXPAGES 4

#if HD_MODE == 0
#if MAXPAGES == 4
#define ARRAYSIZE 4950
#endif

#if MAXPAGES == 9
#define ARRAYSIZE 10870
#endif

#if MAXPAGES == 16
#define ARRAYSIZE 19240
#endif

#if MAXPAGES == 25
#define ARRAYSIZE 30025
#endif

#if MAXPAGES == 36
#define ARRAYSIZE 43217
#endif

#if MAXPAGES == 49
#define ARRAYSIZE 58813
#endif

#if MAXPAGES == 64
#define ARRAYSIZE 76810
#endif

#define IPPD 1200
#endif

#if HD_MODE == 1
#if MAXPAGES == 1
#define ARRAYSIZE 5092
#endif

#if MAXPAGES == 4
#define ARRAYSIZE 14844
#endif

#if MAXPAGES == 9
#define ARRAYSIZE 32600
#endif

#if MAXPAGES == 16
#define ARRAYSIZE 57713
#endif

#if MAXPAGES == 25
#define ARRAYSIZE 90072
#endif

#if MAXPAGES == 36
#define ARRAYSIZE 129650
#endif

#if MAXPAGES == 49
#define ARRAYSIZE 176437
#endif

#if MAXPAGES == 64
#define ARRAYSIZE 230430
#endif

#define IPPD 3600
#endif

class SplatProcessor {
   private:
    char string_[255], sdf_path_[255], opened_, gpsav_, splat_name_[20], splat_version_[10], dashes_[100],
        olditm_;

    double earthradius_, max_range_, forced_erp_, dpp_, ppd_, fzone_clearance_, forced_freq_, clutter_;

    int min_north_, max_north_, min_west_, max_west_, ippd_, mpi_, max_elevation_, min_elevation_, bzerror_,
        contour_threshold_;

    unsigned char got_elevation_pattern_, got_azimuth_pattern_, metric_, dbm_, smooth_contours_;

    struct site {
        double lat;
        double lon;
        float alt;
        char name[50];
        char filename[255];
    };

    struct path {
        double lat[ARRAYSIZE];
        double lon[ARRAYSIZE];
        double elevation[ARRAYSIZE];
        double distance[ARRAYSIZE];
        int length;
    } path_;

    struct dem {
        int min_north;
        int max_north;
        int min_west;
        int max_west;
        int max_el;
        int min_el;
        short data[IPPD][IPPD];
        unsigned char mask[IPPD][IPPD];
        unsigned char signal[IPPD][IPPD];
    } dem_[MAXPAGES];

    struct LR {
        double eps_dielect;
        double sgm_conductivity;
        double eno_ns_surfref;
        double frq_mhz;
        double conf;
        double rel;
        double erp;
        int radio_climate;
        int pol;
        float antenna_pattern[361][1001];
    } LR_;

    struct region {
        unsigned char color[32][3];
        int level[32];
        int levels;
    } region_;

    double start_angle_;  // Start angle in degrees
    double end_angle_;    // End angle in degrees
    int specified_angle_mode_;
    unsigned char transparent_mode_;

    double elev_[ARRAYSIZE + 10];

    SMSplatGenInfo generatedImageInfo_;
    cv::Mat image_;
    std::string homeDir_;
    std::string mapFilePath_;
    std::string lrpFilePathInput_;
    std::string lrpFilePathCache_;
    std::string elevFilePath_;

   public:
    SplatProcessor();

    std::vector<char *> argv_;

    virtual ~SplatProcessor() = default;

    void setLRPFilePath(const std::string& path);
    // Function to set the LRP file path
    
    bool ReadCustomLRParm(struct site txsite, bool forced_read);
    // Function to read LRP parameters


    int interpolate(int y0, int y1, int x0, int x1, int n);
    /* Perform linear interpolation between quantized contour
       levels displayed in field strength and path loss maps.
       If signal level x0 corresponds to color level y0, signal
       level x1 corresponds to color level y1, and signal level
       n falls somewhere between x0 and x1, determine what
       color value n corresponds to between y0 and y1. */

    double arccos(double x, double y);
    /* This function implements the arc cosine function,
       returning a value between 0 and TWOPI. */

    int ReduceAngle(double angle);
    /* This function normalizes the argument to
       an integer angle between 0 and 180 degrees */

    double LonDiff(double lon1, double lon2);
    /* This function returns the short path longitudinal
       difference between longitude1 and longitude2
       as an angle between -180.0 and +180.0 degrees.
       If lon1 is west of lon2, the result is positive.
       If lon1 is east of lon2, the result is negative. */

    char *dec2dms(double decimal);
    /* Converts decimal degrees to degrees, minutes, seconds,
       (DMS) and returns the result as a character string. */

    int PutMask(double lat, double lon, int value);
    /* Lines, text, markings, and coverage areas are stored in a
       mask that is combined with topology data when topographic
       maps are generated by SPLAT!.  This function sets and resets
       bits in the mask based on the latitude and longitude of the
       area pointed to. */

    int OrMask(double lat, double lon, int value);
    /* Lines, text, markings, and coverage areas are stored in a
       mask that is combined with topology data when topographic
       maps are generated by SPLAT!.  This function sets bits in
       the mask based on the latitude and longitude of the area
       pointed to. */

    int GetMask(double lat, double lon);
    /* This function returns the mask bits based on the latitude
       and longitude given. */

    int PutSignal(double lat, double lon, unsigned char signal);
    /* This function writes a signal level (0-255)
       at the specified location for later recall. */

    unsigned char GetSignal(double lat, double lon);
    /* This function reads the signal level (0-255) at the
       specified location that was previously written by the
       complimentary PutSignal() function. */

    double GetElevation(struct site location);
    /* This function returns the elevation (in feet) of any location
       represented by the digital elevation model data in memory.
       Function returns -5000.0 for locations not found in memory. */

    int AddElevation(double lat, double lon, double height);
    /* This function adds a user-defined terrain feature
       (in meters AGL) to the digital elevation model data
       in memory.  Does nothing and returns 0 for locations
       not found in memory. */

    double Distance(struct site site1, struct site site2);
    /* This function returns the great circle distance
       in miles between any two site locations. */

    double Azimuth(struct site source, struct site destination);
    /* This function returns the azimuth (in degrees) to the
       destination as seen from the location of the source. */

    double ElevationAngle(struct site source, struct site destination);
    /* This function returns the angle of elevation (in degrees)
       of the destination as seen from the source location.
       A positive result represents an angle of elevation (uptilt),
       while a negative result represents an angle of depression
       (downtilt), as referenced to a normal to the center of
       the earth. */

    void ReadPath(struct site source, struct site destination);
    /* This function generates a sequence of latitude and
       longitude positions between source and destination
       locations along a great circle path, and stores
       elevation and distance information for points
       along that path in the "path" structure. */

    double ElevationAngle2(struct site source, struct site destination, double er);
    /* This function returns the angle of elevation (in degrees)
       of the destination as seen from the source location, UNLESS
       the path between the sites is obstructed, in which case, the
       elevation angle to the first obstruction is returned instead.
       "er" represents the earth radius. */

    double AverageTerrain(struct site source, double azimuthx, double start_distance,
                          double end_distance);
    /* This function returns the average terrain calculated in
       the direction of "azimuth" (degrees) between "start_distance"
       and "end_distance" (miles) from the source location.  If
       the terrain is all water (non-critical error), -5000.0 is
       returned.  If not enough SDF data has been loaded into
       memory to complete the survey (critical error), then
       -9999.0 is returned. */

    double haat(struct site antenna);
    /* This function returns the antenna's Height Above Average
       Terrain (HAAT) based on FCC Part 73.313(d).  If a critical
       error occurs, such as a lack of SDF data to complete the
       survey, -5000.0 is returned. */

    void PlaceMarker(struct site location);
    /* This function places text and marker data in the mask array
       for illustration on topographic maps generated by SPLAT!.
       By default, SPLAT! centers text information BELOW the marker,
       but may move it above, to the left, or to the right of the
       marker depending on how much room is available on the map,
       or depending on whether the area is already occupied by
       another marker or label.  If no room or clear space is
       available on the map to place the marker and its associated
       text, then the marker and text are not written to the map. */

    double ReadBearing(char *input);
    /* This function takes numeric input in the form of a character
       string, and returns an equivalent bearing in degrees as a
       decimal number (double).  The input may either be expressed
       in decimal format (40.139722) or degree, minute, second
       format (40 08 23).  This function also safely handles
       extra spaces found either leading, trailing, or
       embedded within the numbers expressed in the
       input string.  Decimal seconds are permitted. */

    struct site LoadQTH(char *filename);
    /* This function reads SPLAT! .qth (site location) files.
       The latitude and longitude may be expressed either in
       decimal degrees, or in degree, minute, second format.
       Antenna height is assumed to be expressed in feet above
       ground level (AGL), unless followed by the letter 'M',
       or 'm', or by the word "meters" or "Meters", in which
       case meters is assumed, and is handled accordingly. */

    void LoadPAT(char *filename);
    /* This function reads and processes antenna pattern (.az
       and .el) files that correspond in name to previously
       loaded SPLAT! .lrp files.  */

    int LoadSDF_SDF(char *name);
    /* This function reads uncompressed SPLAT Data Files (.sdf)
       containing digital elevation model data into memory.
       Elevation data, maximum and minimum elevations, and
       quadrangle limits are stored in the first available
       dem[] structure. */

    char *BZfgets(BZFILE *bzfd, unsigned length);
    /* This function returns at most one less than 'length' number
       of characters from a bz2 compressed file whose file descriptor
       is pointed to by *bzfd.  In operation, a buffer is filled with
       uncompressed data (size = BZBUFFER), which is then parsed
       and doled out as NULL terminated character strings every time
       this function is invoked.  A NULL string indicates an EOF
       or error condition. */

    int LoadSDF_BZ(char *name);
    /* This function reads .bz2 compressed SPLAT Data Files containing
       digital elevation model data into memory.  Elevation data,
       maximum and minimum elevations, and quadrangle limits are
       stored in the first available dem[] structure. */

    char LoadSDF(char *name);
    /* This function loads the requested SDF file from the filesystem.
       It first tries to invoke the LoadSDF_SDF() function to load an
       uncompressed SDF file (since uncompressed files load slightly
       faster).  If that attempt fails, then it tries to load a
       compressed SDF file by invoking the LoadSDF_BZ() function.
       If that fails, then we can assume that no elevation data
       exists for the region requested, and that the region
       requested must be entirely over water. */

    void LoadCities(char *filename);
    /* This function reads SPLAT! city/site files, and plots
       the locations and names of the cities and site locations
       read on topographic maps generated by SPLAT! */

    void LoadUDT(char *filename);
    /* This function reads a file containing User-Defined Terrain
       features for their addition to the digital elevation model
       data used by SPLAT!.  Elevations in the UDT file are evaluated
       and then copied into a temporary file under /tmp.  Then the
       contents of the temp file are scanned, and if found to be unique,
       are added to the ground elevations described by the digital
       elevation data already loaded into memory. */

    void LoadBoundaries(char *filename);
    /* This function reads Cartographic Boundary Files available from
       the U.S. Census Bureau, and plots the data contained in those
       files on the PPM Map generated by SPLAT!.  Such files contain
       the coordinates that describe the boundaries of cities,
       counties, and states. */

    char ReadLRParm(struct site txsite, char forced_read);
    /* This function reads ITM parameter data for the transmitter
       site.  The file name is the same as the txsite, except the
       filename extension is .lrp.  If the needed file is not found,
       then the file "splat.lrp" is read from the current working
       directory.  Failure to load this file under a forced_read
       condition will result in the default parameters hard coded
       into this function to be used and written to "splat.lrp". */

    void PlotPath(struct site source, struct site destination, char mask_value);
    /* This function analyzes the path between the source and
       destination locations.  It determines which points along
       the path have line-of-sight visibility to the source.
       Points along with path having line-of-sight visibility
       to the source at an AGL altitude equal to that of the
       destination location are stored by setting bit 1 in the
       mask[][] array, which are displayed in green when PPM
       maps are later generated by SPLAT!. */

    void PlotLRPath(struct site source, struct site destination, unsigned char mask_value,
                    FILE *fd);
    /* This function plots the RF path loss between source and
       destination points based on the ITWOM propagation model,
       taking into account antenna pattern data, if available. */

    void PlotLOSMap(struct site source, double altitude);
    /* This function performs a 360 degree sweep around the
       transmitter site (source location), and plots the
       line-of-sight coverage of the transmitter on the SPLAT!
       generated topographic map based on a receiver located
       at the specified altitude (in feet AGL).  Results
       are stored in memory, and written out in the form
       of a topographic map when the WritePPM() function
       is later invoked. */

    double AdjustAngleForNegativeXAxis(double angle);
    // Add up 90 degrees to shift reference to the positive y-axis instead of negative x-axis.

    void PlotLRMapSpecifiedAngles(struct site source, double altitude, char *plo_filename,
                                  double start_angle, double end_angle);
    /* This function performs a 360 degree sweep around the
       transmitter site (source location), and plots the
       Irregular Terrain Model attenuation on the SPLAT!
       generated topographic map based on a receiver located
       at the specified altitude (in feet AGL).  Results
       are stored in memory, and written out in the form
       of a topographic map when the WritePPMLR() or
       WritePPMSS() functions are later invoked. */

    void PlotLRMap(struct site source, double altitude, char *plo_filename);
    /* This function performs a 360 degree sweep around the
       transmitter site (source location), and plots the
       Irregular Terrain Model attenuation on the SPLAT!
       generated topographic map based on a receiver located
       at the specified altitude (in feet AGL).  Results
       are stored in memory, and written out in the form
       of a topographic map when the WritePPMLR() or
       WritePPMSS() functions are later invoked. */

    void LoadSignalColors(struct site xmtr);

    void LoadLossColors();

    void LoadDBMColors();

    void WritePPM(char *filename, unsigned char geo, unsigned char kml, unsigned char ngs,
                  struct site *xmtr, unsigned char txsites);
    /* This function generates a topographic map in Portable Pix Map
       (PPM) format based on logarithmically scaled topology data,
       as well as the content of flags held in the mask[][] array.
       The image created is rotated counter-clockwise 90 degrees
       from its representation in dem[][] so that north points
       up and east points right in the image generated. */

    void WritePPMLR(char *filename, unsigned char geo, unsigned char kml, unsigned char ngs,
                    struct site *xmtr, unsigned char txsites);
    /* This function generates a topographic map in Portable Pix Map
       (PPM) format based on the content of flags held in the mask[][]
       array (only).  The image created is rotated counter-clockwise
       90 degrees from its representation in dem[][] so that north
       points up and east points right in the image generated. */

    void write_image_info_to_txt(const std::string &filename, double min_x, double min_y,
                                 double max_x, double max_y, int image_width, int image_height);
    // Function to write image info to a text file

    void updateCoverageInfo(const char *coverage_name, double latitude, double longitude, double radius);
    // Function to set the coverage name

    void updateImageBounds(const char *pngfile, double min_x, double min_y, double max_x,
                          double max_y, int image_width, int image_height);
    // Function to write image info to a struct in the SMSplat

    void WritePPMSS(char *filename, unsigned char geo, unsigned char kml, unsigned char ngs,
                    struct site *xmtr, unsigned char txsites);
    /* This function generates a topographic map in Portable Pix Map
       (PPM) format based on the signal strength values held in the
       signal[][] array.  The image created is rotated counter-clockwise
       90 degrees from its representation in dem[][] so that north
       points up and east points right in the image generated. */

    void WritePPMDBM(char *filename, unsigned char ngs, struct site *xmtr, unsigned char txsites);
    /* This function generates a topographic map in Portable Pix Map
       (PPM) format based on the signal power level values held in the
       signal[][] array.  The image created is rotated counter-clockwise
       90 degrees from its representation in dem[][] so that north
       points up and east points right in the image generated. */

    void GraphTerrain(struct site source, struct site destination, char *name);
    /* This function invokes gnuplot to generate an appropriate
       output file indicating the terrain profile between the source
       and destination locations when the -p command line option
       is used.  "basename" is the name assigned to the output
       file generated by gnuplot.  The filename extension is used
       to set gnuplot's terminal setting and output file type.
       If no extension is found, .png is assumed.  */

    void GraphElevation(struct site source, struct site destination, char *name);
    /* This function invokes gnuplot to generate an appropriate
       output file indicating the terrain elevation profile between
       the source and destination locations when the -e command line
       option is used.  "basename" is the name assigned to the output
       file generated by gnuplot.  The filename extension is used
       to set gnuplot's terminal setting and output file type.
       If no extension is found, .png is assumed.  */

    void GraphHeight(struct site source, struct site destination, char *name,
                     unsigned char fresnel_plot, unsigned char normalized);
    /* This function invokes gnuplot to generate an appropriate
       output file indicating the terrain height profile between
       the source and destination locations referenced to the
       line-of-sight path between the receive and transmit sites
       when the -h or -H command line option is used.  "basename"
       is the name assigned to the output file generated by gnuplot.
       The filename extension is used to set gnuplot's terminal
       setting and output file type.  If no extension is found,
       .png is assumed.  */

    void ObstructionAnalysis(struct site xmtr, struct site rcvr, double f, FILE *outfile);
    /* Perform an obstruction analysis along the
       path between receiver and transmitter. */

    void PathReport(struct site source, struct site destination, char *name, char graph_it);
    /* This function writes a SPLAT! Path Report (name.txt) to
       the filesystem.  If (graph_it == 1), then gnuplot is invoked
       to generate an appropriate output file indicating the ITM
       model loss between the source and destination locations.
       "filename" is the name assigned to the output file generated
       by gnuplot.  The filename extension is used to set gnuplot's
       terminal setting and output file type.  If no extension is
       found, .png is assumed. */

    // Function to extract the directory path up to the PPM file
    void extractSplatPath(const char *ppmFilePath, char *outputPath, size_t outputPathSize);

    void SiteReport(const char *ppmFilePath, struct site xmtr);

    void LoadTopoData(int max_lon, int min_lon, int max_lat, int min_lat);
    /* This function loads the SDF files required
       to cover the limits of the region specified. */

    int LoadANO(char *filename);
    /* This function reads a SPLAT! alphanumeric output
       file (-ani option) for analysis and/or map generation. */

    void WriteKML(struct site source, struct site destination);

    void printHelp(const char *splat_name, const char *splat_version, int &y);

    void prepareHeader(const char *splat_name, const char *splat_version, char *header);

    void parseArguments(int argc, char *argv[], char *header, int &y);

    void process();

    virtual void setParameters(const SMSplatInputInfo &params);

    void resetSplat();

    // Add this new method to get the generated image info
    SMSplatGenInfo getGeneratedImageInfo() const { return generatedImageInfo_; }
    const cv::Mat &getImageBuffer() const { return image_; }
};

class ScopedTimer {
private:
    std::chrono::time_point<std::chrono::high_resolution_clock> start_;
    std::string name_;

public:
    explicit ScopedTimer(std::string name) : start_(std::chrono::high_resolution_clock::now()), name_(std::move(name)) {}

    ~ScopedTimer() {
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start_);
        std::cout << name_ << " took " << duration.count() / 1000.0 << " ms" << std::endl;
    }

    // Prevent copying
    ScopedTimer(const ScopedTimer&) = delete;
    ScopedTimer& operator=(const ScopedTimer&) = delete;
};

#endif  // SPLAT_PROCESSOR_H
